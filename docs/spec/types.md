# TESA Type System

## Overview

TESA recognizes six (and only six) distinct types.

 - None
 - Number
 - Character
 - Array
 - Function
 - Container

Of these types the first four are immutable[^1] and the last two are mutable[^2].

Certain common types are not included in TESA, but these generally have replacements:

 - Ints and Floats are not separated.
 - Booleans are just the numbers `0` and `1`.
 - Strings are just one dimensional arrays of characters.
 - Objects, Maps, and various other types that associate keys to values are represented by the single container type.

To get the type of an object in TESA the `typeof` function can be used. The exact return set of values for this function is left up to the implementation to determine but it is guaranteed that there will be six distinct values which can be compared using the `=`, `=/=`, `match`, and `not-match` functions. In practice implementers will want to use some sort of numerical enum or set of representation characters for the distinct values. The `TYPE` container in the standard library contains the variables `NONE`, `NUMBER`, `CHARACTER`, `ARRAY`, `FUNCTION`, and `CONTAINER` which can be compared against. (i.e. `{{typeof x} = TYPE.NUMBER}`) to check if a value is a number.

A few useful cast functions are provided:

 - `repr`, short for representation, converts an object of any type into a string. It can optionally take an additional second argument specifying formatting details.
 - `num` converts a string to a number or returns `·` if no such conversion is possible. It can optionally take a second argument specifying parsing rules.
 - `bool` converts an object of any type into either the number `0` or `1`. It cannot fail.

In some contexts an implicit cast to either a string (as is the case in `print`) or a boolean (as in `lor`) is unambiguously desired. In these cases the `repr` and `bool` functions are used internally.

It should also be noted the following underlines the *user-facing* types of the language. Implementations may use more than one internal type per user facing type under the hood for various reasons including convenience and efficiency. However, these extra internal types should not be visible to user-programs.

[^1]: Arrays in TESA are considered immutable in the sense that the elements in an array cannot be changed, however arrays can contain mutable elements which in turn can change.

[^2]: Containers are mutable in the trivial sense that their elements can be updated, functions are mutable in the sense that they can depend on and update mutable variables in an enclosing scope allowing their behavior to change over the course of a program.

## None

None is the simplest type in TESA, having one possible value also called None. None is implicitly the result any time a value is expected but none is provided. It is the value of:
 - An empty expression `()`.
 - An unprovided function parameter.
 - An unset field in a container.
 - The `NONE` constant from the standard library
   
   And more.

As such it is not possible to distinguish between an explicit none provided by user-code or one implicitly generated by the lack of any other value. This is a good thing as it allows setting a value to none to delete it instead of having to have an extra explicit notation for that purpose.

### Literals

There is no literal for None so the most common ways of explicitly obtaining the value are by using an empty expression `()` or using the constant `NONE` from the standard library.

### Type Conversions

 - `{repr NONE}` is `"·"` (that's the middle dot).
 - `{bool NONE}` is `0`.

## Number

TESA uses its own fancy number format with the following specs:
 - Arbitrary precision integers are supported.
 - Non-integer numbers with up to 53 bits of precision (the same as an IEEE-754 64 bit float) are supported. (An implementation may provide additional precision, but 53 bits is the minimum)
 - Zero is unsigned so both `0` and `-0` produce the same interval value.
 - The two signed infinities `oo` and `-oo` are both supported.
 - There is no NaN value, instead various functions may choose instead choose to:
   - Normalize indeterminate forms. (i.e. `(0 / 0)` gives `0`)
   - Return `·` instead. (i.e. `{num "Abacaba"}` gives `·`)
   - Simply fail.

### Literals

Numbers can be constructed in a variety of ways:

   The usual:
 - Decimal Literals: `123.45`
 - Hex Literals: `0x21.a` (unlike other languages TESA supports radix points in its non decimal literals)
 - Binary Literals: `0b11101010`
 - Octal Literals (both `0o` and `0` prefixed): `012` or `0o12`
 
   And the slightly more unusual:
 - Senary/Seximal (base-6) Literals: `-0s45`
 - Duodecimal/Dozenal (base-12) Literals: `0d9↊.↋1` (`a`/`A`, `t`/`T`, `x`/`X`, and `↊` can all by used as the digit for 10 and `b`/`B`, `e`/`E`, `z`/`Z`, and `↋` as the digit for 11)
 - Base 36 (full-alphabet) Literals: `0aFooBar1`
 
   Note that all bases > 10 are case insensitive
 - Infinity Literals: `oo` and `-oo`

### Type Conversions

 - `{repr n}` is the decimal representation of n. If n is negative this will include a leading `-` and if it is not an integer it will include a radix point `.`. The two infinities have dedicated representations.
   - `{repr 12}` is `"12"`
   - `{repr -81}` is `"-81"`
   - `{repr 3.14}` is `"3.14"`
   - `{repr oo}` is `"∞"` and `{repr -oo}` is `"-∞"`
   
   A second parameter can be provided to `repr` to adjust this behavior, see [`repr`](./builtins.md#repr) for details.
 - `{bool n}` is `0` if and only if `n` is `0`, otherwise it is `1`.

## Character

A character in TESA represents a single unicode code-point. This means that strings can be thought of as being in UTF-32 for convenience.

### Literals

 - Character literals are wrapped in single quotes (`'`) (i.e. `'x'`) and can use escape sequences. (i.e. `'\0'`)
 - String literals represent one dimensional arrays of characters, and are wrapped in double quotes (`"`) (i.e. `"FooBar"`) and can also use escape sequences.

Escape sequences start with a backslash (`\`) and have the following options. (Stealing from C, like everyone else)

 - `\a`, `\b`, `\e`, `\f`, `\n`, `\r`, `\t`, `\v` for ␇, ␈, ␛, ␛, ␊, ␍, ␉, and ␋ respectively.
 - `\\`, `\'`, and `\"` for `\`, `'`, and `"` respectively.
 - `\n`, `\nn`, and `\nnn` for the character with the corresponding 1-3 digit octal code point.
 - `\xdd` for the character with the corresponding 2 digit hexadecimal code point.
 - `\udddd` for the character with the corresponding 4 digit hexadecimal code point.
 - `\u{digits}` for the character with the corresponding n digit hexadecimal code point. (Actually, this one is stolen from Javascript)

### Type Conversions

 - `{repr c}` is generally `"'c'"`. If `c` is non-printable or must be escaped an escape sequence is used prioritizing escape sequences in the order laid out in the literals section.
 - `{bool c}` is `0` if and only if `c` is the null character (`'\0'`), otherwise it is `1`.

## Array

...

## Function

...

## Container

...

